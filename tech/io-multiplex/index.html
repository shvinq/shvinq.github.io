<!doctype html><html lang=zh-cn><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=utf-8><meta name=generator content="Hugo 0.95.0"><meta name=theme-color content="#fff"><meta name=color-scheme content="light dark"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><title>IO多路复用详解 | SHVINQ</title><link rel=stylesheet href=/css/meme.min.css><script src=/js/meme.min.js></script>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&family=Cinzel+Decorative:wght@700&display=swap" media=print onload='this.media="all"'><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&family=Cinzel+Decorative:wght@700&display=swap"></noscript><meta name=author content="shvinq"><meta name=description content="I/O 多路复用之select、poll、epoll详解 select，poll，epoll都是IO多路复用……"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=mask-icon href=/icons/safari-pinned-tab.svg color=#fff><link rel=apple-touch-icon sizes=180x180 href=/icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="SHVINQ"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="SHVINQ"><meta name=msapplication-starturl content="../../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../../icons/mstile-150x150.png"><link rel=manifest href=/manifest.json><link rel=canonical href=https://shvinq.com/tech/io-multiplex/><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","datePublished":"2021-10-24T13:05:35+08:00","dateModified":"2022-03-27T21:52:56+08:00","url":"https://shvinq.com/tech/io-multiplex/","headline":"IO多路复用详解","description":"I/O 多路复用之select、poll、epoll详解 select，poll，epoll都是IO多路复用……","inLanguage":"zh-CN","articleSection":"tech","wordCount":4892,"image":"https://shvinq.com/icons/cool1.png","author":{"@type":"Person","description":"Go Deep","email":"zhoushuiqing321@gmail.com","image":"https://shvinq.com/icons/cool1.png","url":"https://shvinq.com/","name":"shvinq"},"license":"在保留本文作者及本文链接的前提下，非商业用途随意转载分享。","publisher":{"@type":"Organization","name":"SHVINQ","logo":{"@type":"ImageObject","url":"https://shvinq.com/icons/cool1.png"},"url":"https://shvinq.com/"},"mainEntityOfPage":{"@type":"WebSite","@id":"https://shvinq.com/"}}</script><meta name=twitter:card content="summary"><meta property="og:title" content="IO多路复用详解"><meta property="og:description" content="I/O 多路复用之select、poll、epoll详解 select，poll，epoll都是IO多路复用……"><meta property="og:url" content="https://shvinq.com/tech/io-multiplex/"><meta property="og:site_name" content="SHVINQ"><meta property="og:locale" content="zh"><meta property="og:image" content="https://shvinq.com/icons/cool1.png"><meta property="og:type" content="article"><meta property="article:published_time" content="2021-10-24T13:05:35+08:00"><meta property="article:modified_time" content="2022-03-27T21:52:56+08:00"><meta property="article:section" content="tech"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap" media=print onload='this.media="all"'><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap"></noscript></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=/ class=brand>SHVINQ</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon life"><path d="M301.1 212c4.4 4.4 4.4 11.9.0 16.3l-9.7 9.7c-4.4 4.7-11.9 4.7-16.6.0l-10.5-10.5c-4.4-4.7-4.4-11.9.0-16.6l9.7-9.7c4.4-4.4 11.9-4.4 16.6.0l10.5 10.8zm-30.2-19.7c3-3 3-7.8.0-10.5-2.8-3-7.5-3-10.5.0-2.8 2.8-2.8 7.5.0 10.5 3.1 2.8 7.8 2.8 10.5.0zm-26 5.3c-3 2.8-3 7.5.0 10.2 2.8 3 7.5 3 10.5.0 2.8-2.8 2.8-7.5.0-10.2-3-3-7.7-3-10.5.0zm72.5-13.3c-19.9-14.4-33.8-43.2-11.9-68.1 21.6-24.9 40.7-17.2 59.8.8 11.9 11.3 29.3 24.9 17.2 48.2-12.5 23.5-45.1 33.2-65.1 19.1zm47.7-44.5c-8.9-10-23.3 6.9-15.5 16.1 7.4 9 32.1 2.4 15.5-16.1zM504 256c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-66.2 42.6c2.5-16.1-20.2-16.6-25.2-25.7-13.6-24.1-27.7-36.8-54.5-30.4 11.6-8 23.5-6.1 23.5-6.1.3-6.4.0-13-9.4-24.9 3.9-12.5.3-22.4.3-22.4 15.5-8.6 26.8-24.4 29.1-43.2 3.6-31-18.8-59.2-49.8-62.8-22.1-2.5-43.7 7.7-54.3 25.7-23.2 40.1 1.4 70.9 22.4 81.4-14.4-1.4-34.3-11.9-40.1-34.3-6.6-25.7 2.8-49.8 8.9-61.4.0.0-4.4-5.8-8-8.9.0.0-13.8.0-24.6 5.3 11.9-15.2 25.2-14.4 25.2-14.4.0-6.4-.6-14.9-3.6-21.6-5.4-11-23.8-12.9-31.7 2.8.1-.2.3-.4.4-.5-5 11.9-1.1 55.9 16.9 87.2-2.5 1.4-9.1 6.1-13 10-21.6 9.7-56.2 60.3-56.2 60.3-28.2 10.8-77.2 50.9-70.6 79.7.3 3 1.4 5.5 3 7.5-2.8 2.2-5.5 5-8.3 8.3-11.9 13.8-5.3 35.2 17.7 24.4 15.8-7.2 29.6-20.2 36.3-30.4.0.0-5.5-5-16.3-4.4 27.7-6.6 34.3-9.4 46.2-9.1 8 3.9 8-34.3 8-34.3.0-14.7-2.2-31-11.1-41.5 12.5 12.2 29.1 32.7 28 60.6-.8 18.3-15.2 23-15.2 23-9.1 16.6-43.2 65.9-30.4 106 0 0-9.7-14.9-10.2-22.1-17.4 19.4-46.5 52.3-24.6 64.5 26.6 14.7 108.8-88.6 126.2-142.3 34.6-20.8 55.4-47.3 63.9-65 22 43.5 95.3 94.5 101.1 59z"/></svg><span class=menu-item-name>生活</span></a></li><li class="menu-item active"><a href=/tech/><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tech"><path d="M512 256c0 141.2-114.7 256-256 256C114.8 512 0 397.3.0 256S114.7.0 256 0s256 114.7 256 256zm-32 0c0-123.2-100.3-224-224-224C132.5 32 32 132.5 32 256s100.5 224 224 224 224-100.5 224-224zM160.9 124.6l86.9 37.1-37.1 86.9-86.9-37.1 37.1-86.9zm110 169.1 46.6 94h-14.6l-50-1e2-48.9 1e2h-14l51.1-106.9-22.3-9.4 6-14 68.6 29.1-6 14.3-16.5-7.1zm-11.8-116.3 68.6 29.4-29.4 68.3L230 246l29.1-68.6zm80.3 42.9 54.6 23.1-23.4 54.3-54.3-23.1 23.1-54.3z"/></svg><span class=menu-item-name>技术</span></a></li><li class=menu-item><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" class="icon about"><path d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 96c48.6.0 88 39.4 88 88s-39.4 88-88 88-88-39.4-88-88 39.4-88 88-88zm0 344c-58.7.0-111.3-26.6-146.5-68.2 18.8-35.4 55.6-59.8 98.5-59.8 2.4.0 4.8.4 7.1 1.1 13 4.2 26.6 6.9 40.9 6.9s28-2.7 40.9-6.9c2.3-.7 4.7-1.1 7.1-1.1 42.9.0 79.7 24.4 98.5 59.8C359.3 421.4 306.7 448 248 448z"/></svg><span class=menu-item-name>关于</span></a></li><li class=menu-item><a id=theme-switcher href=#><span class="icon theme-icon-light">🌝</span><span class="icon theme-icon-dark">🌚</span></a></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label>
<label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><div class=main-inner><article class="content post h-entry" data-align=justify data-type=tech data-toc-num=true><h1 class="post-title p-name">IO多路复用详解</h1><div class="post-body e-content"><h2 id=io-多路复用之selectpollepoll详解><a href=#io-多路复用之selectpollepoll详解 class=anchor-link>#</a>I/O 多路复用之select、poll、epoll详解</h2><p>select，poll，epoll都是IO多路复用的机制。</p><p>I/O多路复用就是通过一种机制: <strong>一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</strong></p><p>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><h2 id=select><a href=#select class=anchor-link>#</a>Select</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>select</span> <span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=n>fd_set</span> <span class=o>*</span><span class=n>readfds</span><span class=p>,</span> <span class=n>fd_set</span> <span class=o>*</span><span class=n>writefds</span><span class=p>,</span> <span class=n>fd_set</span> <span class=o>*</span><span class=n>exceptfds</span><span class=p>,</span> <span class=k>struct</span> <span class=n>timeval</span> <span class=o>*</span><span class=n>timeout</span><span class=p>);</span>
</span></span></code></pre></div><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有文件描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为0即可，如果设置为NULL是永远等待下去，直到有描述符准备好再返回），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p><p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p><h2 id=poll><a href=#poll class=anchor-link>#</a>Poll</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>poll</span> <span class=p>(</span><span class=k>struct</span> <span class=n>pollfd</span> <span class=o>*</span><span class=n>fds</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>nfds</span><span class=p>,</span> <span class=kt>int</span> <span class=n>timeout</span><span class=p>);</span>
</span></span></code></pre></div><p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>pollfd</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span><span class=p>;</span> <span class=cm>/* file descriptor */</span>
</span></span><span class=line><span class=cl>    <span class=kt>short</span> <span class=n>events</span><span class=p>;</span> <span class=cm>/* requested events to watch */</span>
</span></span><span class=line><span class=cl>    <span class=kt>short</span> <span class=n>revents</span><span class=p>;</span> <span class=cm>/* returned events witnessed */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>pollfd结构包含了要监视的event和发生的event，不再使用select <code>参数-值</code>传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p><blockquote><p>从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p></blockquote><h2 id=epoll><a href=#epoll class=anchor-link>#</a>Epoll</h2><p>相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p><h3 id=一epoll操作过程><a href=#一epoll操作过程 class=anchor-link>#</a>一、epoll操作过程</h3><p>epoll操作过程需要三个接口，分别如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>epoll_create</span><span class=p>(</span><span class=kt>int</span> <span class=n>size</span><span class=p>)</span><span class=err>；</span><span class=c1>//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>epoll_ctl</span><span class=p>(</span><span class=kt>int</span> <span class=n>epfd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>op</span><span class=p>,</span> <span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>epoll_event</span> <span class=o>*</span><span class=n>event</span><span class=p>)</span><span class=err>；</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>epoll_wait</span><span class=p>(</span><span class=kt>int</span> <span class=n>epfd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>epoll_event</span> <span class=o>*</span> <span class=n>events</span><span class=p>,</span> <span class=kt>int</span> <span class=n>maxevents</span><span class=p>,</span> <span class=kt>int</span> <span class=n>timeout</span><span class=p>);</span>
</span></span></code></pre></div><p><strong>1. int epoll_create(int size);</strong>
创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，<code>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议</code>。
当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p><p><strong>2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</strong>
函数是对指定描述符fd执行op操作。</p><ul><li>epfd：是epoll_create()的返回值。</li><li>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</li><li>fd：是需要监听的fd（文件描述符）</li><li>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>epoll_event</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>__uint32_t</span> <span class=n>events</span><span class=p>;</span>  <span class=cm>/* Epoll events */</span>
</span></span><span class=line><span class=cl>  <span class=n>epoll_data_t</span> <span class=n>data</span><span class=p>;</span>  <span class=cm>/* User data variable */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//events可以是以下几个宏的集合：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>EPOLLIN</span> <span class=err>：表示对应的文件描述符可以读（包括对端</span><span class=n>SOCKET正常关闭</span><span class=err>）；</span>
</span></span><span class=line><span class=cl><span class=n>EPOLLOUT</span><span class=err>：表示对应的文件描述符可以写；</span>
</span></span><span class=line><span class=cl><span class=n>EPOLLPRI</span><span class=err>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span>
</span></span><span class=line><span class=cl><span class=n>EPOLLERR</span><span class=err>：表示对应的文件描述符发生错误；</span>
</span></span><span class=line><span class=cl><span class=n>EPOLLHUP</span><span class=err>：表示对应的文件描述符被挂断；</span>
</span></span><span class=line><span class=cl><span class=n>EPOLLET</span><span class=err>：</span> <span class=err>将</span><span class=n>EPOLL设为边缘触发</span><span class=p>(</span><span class=n>Edge</span> <span class=n>Triggered</span><span class=p>)</span><span class=err>模式，这是相对于水平触发</span><span class=p>(</span><span class=n>Level</span> <span class=n>Triggered</span><span class=p>)</span><span class=err>来说的。</span>
</span></span><span class=line><span class=cl><span class=n>EPOLLONESHOT</span><span class=err>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个</span><span class=n>socket的话</span><span class=err>，需要再次把这个</span><span class=n>socket加入到EPOLL队列里</span>
</span></span></code></pre></div><p><strong>3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong>
等待epfd上的io事件，最多返回maxevents个事件。
参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p><h3 id=二工作模式><a href=#二工作模式 class=anchor-link>#</a>二、工作模式</h3><p>epoll对文件描述符的操作有两种模式：<strong>LT（level trigger）<strong>和</strong>ET（edge trigger）</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：</p><ul><li><strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li><li><strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</li></ul><h4 id=1-lt模式><a href=#1-lt模式 class=anchor-link>#</a>1. LT模式</h4><p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p><h4 id=2-et模式><a href=#2-et模式 class=anchor-link>#</a>2. ET模式</h4><p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd做IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p><p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h4 id=3-总结><a href=#3-总结 class=anchor-link>#</a>3. 总结</h4><p><strong>假如有这样一个例子：</strong></p><ol><li>我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符</li><li>这个时候从管道的另一端被写入了2KB的数据</li><li>调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作</li><li>然后我们读取了1KB的数据</li><li>调用epoll_wait(2)......</li></ol><p><strong>LT模式：</strong>
如果是LT模式，那么在第5步调用epoll_wait(2)之后，仍然能受到通知。</p><p><strong>ET模式：</strong>
如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait(2)之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。</p><p>当使用epoll的ET模型来工作时，当产生了一个EPOLLIN事件后，
读数据的时候需要考虑的是当recv()返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=n>rs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>buflen</span> <span class=o>=</span> <span class=n>recv</span><span class=p>(</span><span class=n>activeevents</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>data</span><span class=p>.</span><span class=n>fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  	<span class=k>if</span><span class=p>(</span><span class=n>buflen</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    	<span class=c1>// 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=c1>// 在这里就当作是该次事件已处理完成
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=k>if</span><span class=p>(</span><span class=n>errno</span> <span class=o>==</span> <span class=n>EAGAIN</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    	<span class=k>else</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  	<span class=p>}</span>
</span></span><span class=line><span class=cl>  	<span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>buflen</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  	<span class=p>{</span>
</span></span><span class=line><span class=cl>     	<span class=c1>// 这里表示对端的socket已正常关闭.
</span></span></span><span class=line><span class=cl><span class=c1></span>  	<span class=p>}</span>
</span></span><span class=line><span class=cl> 	<span class=k>if</span><span class=p>(</span><span class=n>buflen</span> <span class=o>==</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>)</span> <span class=n>rs</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>   <span class=c1>// 需要再次读取
</span></span></span><span class=line><span class=cl><span class=c1></span> 	<span class=k>else</span> <span class=n>rs</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p><strong>Linux中的EAGAIN含义</strong></p></blockquote><p>Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。
从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。</p><ul><li><p>例如，以 O_NONBLOCK的标志打开文件<code>/socket/FIFO</code>，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。</p></li><li><p>又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</p></li></ul><h3 id=三代码演示><a href=#三代码演示 class=anchor-link>#</a>三、代码演示</h3><p>下面是一段不完整的代码且格式不对，意在表述上面的过程，去掉了一些模板代码。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define IPADDRESS   &#34;127.0.0.1&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#define PORT        8787
</span></span></span><span class=line><span class=cl><span class=cp>#define MAXSIZE     1024
</span></span></span><span class=line><span class=cl><span class=cp>#define LISTENQ     5
</span></span></span><span class=line><span class=cl><span class=cp>#define FDSIZE      1000
</span></span></span><span class=line><span class=cl><span class=cp>#define EPOLLEVENTS 100
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>listenfd</span> <span class=o>=</span> <span class=n>socket_bind</span><span class=p>(</span><span class=n>IPADDRESS</span><span class=p>,</span><span class=n>PORT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>epoll_event</span> <span class=n>events</span><span class=p>[</span><span class=n>EPOLLEVENTS</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//创建一个描述符
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>epollfd</span> <span class=o>=</span> <span class=n>epoll_create</span><span class=p>(</span><span class=n>FDSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//添加监听描述符事件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>add_event</span><span class=p>(</span><span class=n>epollfd</span><span class=p>,</span><span class=n>listenfd</span><span class=p>,</span><span class=n>EPOLLIN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//循环等待
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span> <span class=p>;</span> <span class=p>;</span> <span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=c1>//该函数返回已经准备好的描述符事件数目
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ret</span> <span class=o>=</span> <span class=n>epoll_wait</span><span class=p>(</span><span class=n>epollfd</span><span class=p>,</span><span class=n>events</span><span class=p>,</span><span class=n>EPOLLEVENTS</span><span class=p>,</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//处理接收到的连接
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>handle_events</span><span class=p>(</span><span class=n>epollfd</span><span class=p>,</span><span class=n>events</span><span class=p>,</span><span class=n>ret</span><span class=p>,</span><span class=n>listenfd</span><span class=p>,</span><span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//事件处理函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=n>handle_events</span><span class=p>(</span><span class=kt>int</span> <span class=n>epollfd</span><span class=p>,</span><span class=k>struct</span> <span class=n>epoll_event</span> <span class=o>*</span><span class=n>events</span><span class=p>,</span><span class=kt>int</span> <span class=n>num</span><span class=p>,</span><span class=kt>int</span> <span class=n>listenfd</span><span class=p>,</span><span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=c1>//进行遍历;这里只要遍历已经准备好的io事件。num并不是当初epoll_create时的FDSIZE。
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>num</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=n>fd</span> <span class=o>=</span> <span class=n>events</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>data</span><span class=p>.</span><span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>//根据描述符的类型和事件类型进行处理
</span></span></span><span class=line><span class=cl><span class=c1></span>         <span class=k>if</span> <span class=p>((</span><span class=n>fd</span> <span class=o>==</span> <span class=n>listenfd</span><span class=p>)</span> <span class=o>&amp;&amp;</span><span class=p>(</span><span class=n>events</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>events</span> <span class=o>&amp;</span> <span class=n>EPOLLIN</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>handle_accpet</span><span class=p>(</span><span class=n>epollfd</span><span class=p>,</span><span class=n>listenfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>         <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>events</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>events</span> <span class=o>&amp;</span> <span class=n>EPOLLIN</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>do_read</span><span class=p>(</span><span class=n>epollfd</span><span class=p>,</span><span class=n>fd</span><span class=p>,</span><span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>         <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>events</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>events</span> <span class=o>&amp;</span> <span class=n>EPOLLOUT</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>do_write</span><span class=p>(</span><span class=n>epollfd</span><span class=p>,</span><span class=n>fd</span><span class=p>,</span><span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>     <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//添加事件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=n>add_event</span><span class=p>(</span><span class=kt>int</span> <span class=n>epollfd</span><span class=p>,</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span><span class=kt>int</span> <span class=n>state</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>epoll_event</span> <span class=n>ev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ev</span><span class=p>.</span><span class=n>events</span> <span class=o>=</span> <span class=n>state</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ev</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>fd</span> <span class=o>=</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>epoll_ctl</span><span class=p>(</span><span class=n>epollfd</span><span class=p>,</span><span class=n>EPOLL_CTL_ADD</span><span class=p>,</span><span class=n>fd</span><span class=p>,</span><span class=o>&amp;</span><span class=n>ev</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//处理接收到的连接
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=n>handle_accpet</span><span class=p>(</span><span class=kt>int</span> <span class=n>epollfd</span><span class=p>,</span><span class=kt>int</span> <span class=n>listenfd</span><span class=p>){</span>
</span></span><span class=line><span class=cl>     <span class=kt>int</span> <span class=n>clifd</span><span class=p>;</span>     
</span></span><span class=line><span class=cl>     <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=n>cliaddr</span><span class=p>;</span>     
</span></span><span class=line><span class=cl>     <span class=n>socklen_t</span>  <span class=n>cliaddrlen</span><span class=p>;</span>     
</span></span><span class=line><span class=cl>     <span class=n>clifd</span> <span class=o>=</span> <span class=n>accept</span><span class=p>(</span><span class=n>listenfd</span><span class=p>,(</span><span class=k>struct</span> <span class=n>sockaddr</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>cliaddr</span><span class=p>,</span><span class=o>&amp;</span><span class=n>cliaddrlen</span><span class=p>);</span>     
</span></span><span class=line><span class=cl>     <span class=k>if</span> <span class=p>(</span><span class=n>clifd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>         
</span></span><span class=line><span class=cl>     <span class=n>perror</span><span class=p>(</span><span class=s>&#34;accpet error:&#34;</span><span class=p>);</span>     
</span></span><span class=line><span class=cl>     <span class=k>else</span> <span class=p>{</span>         
</span></span><span class=line><span class=cl>         <span class=n>printf</span><span class=p>(</span><span class=s>&#34;accept a new client: %s:%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>inet_ntoa</span><span class=p>(</span><span class=n>cliaddr</span><span class=p>.</span><span class=n>sin_addr</span><span class=p>),</span><span class=n>cliaddr</span><span class=p>.</span><span class=n>sin_port</span><span class=p>);</span>                       <span class=c1>//添加一个客户描述符和事件         
</span></span></span><span class=line><span class=cl><span class=c1></span>         <span class=n>add_event</span><span class=p>(</span><span class=n>epollfd</span><span class=p>,</span><span class=n>clifd</span><span class=p>,</span><span class=n>EPOLLIN</span><span class=p>);</span>     
</span></span><span class=line><span class=cl>     <span class=p>}</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//读处理
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=n>do_read</span><span class=p>(</span><span class=kt>int</span> <span class=n>epollfd</span><span class=p>,</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span><span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>nread</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>nread</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span><span class=n>buf</span><span class=p>,</span><span class=n>MAXSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>nread</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>     <span class=p>{</span>         
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;read error:&#34;</span><span class=p>);</span>         
</span></span><span class=line><span class=cl>        <span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span> <span class=c1>//记住close fd        
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>delete_event</span><span class=p>(</span><span class=n>epollfd</span><span class=p>,</span><span class=n>fd</span><span class=p>,</span><span class=n>EPOLLIN</span><span class=p>);</span> <span class=c1>//删除监听 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>nread</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>     <span class=p>{</span>         
</span></span><span class=line><span class=cl>        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;client close.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span> <span class=c1>//记住close fd       
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>delete_event</span><span class=p>(</span><span class=n>epollfd</span><span class=p>,</span><span class=n>fd</span><span class=p>,</span><span class=n>EPOLLIN</span><span class=p>);</span> <span class=c1>//删除监听 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>     
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>         
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;read message is : %s&#34;</span><span class=p>,</span><span class=n>buf</span><span class=p>);</span>        
</span></span><span class=line><span class=cl>        <span class=c1>//修改描述符对应的事件，由读改为写         
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>modify_event</span><span class=p>(</span><span class=n>epollfd</span><span class=p>,</span><span class=n>fd</span><span class=p>,</span><span class=n>EPOLLOUT</span><span class=p>);</span>     
</span></span><span class=line><span class=cl>    <span class=p>}</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//写处理
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=n>do_write</span><span class=p>(</span><span class=kt>int</span> <span class=n>epollfd</span><span class=p>,</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span><span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>)</span> <span class=p>{</span>     
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>nwrite</span><span class=p>;</span>     
</span></span><span class=line><span class=cl>    <span class=n>nwrite</span> <span class=o>=</span> <span class=n>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span><span class=n>buf</span><span class=p>,</span><span class=n>strlen</span><span class=p>(</span><span class=n>buf</span><span class=p>));</span>     
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>nwrite</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>){</span>         
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;write error:&#34;</span><span class=p>);</span>        
</span></span><span class=line><span class=cl>        <span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>   <span class=c1>//记住close fd       
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>delete_event</span><span class=p>(</span><span class=n>epollfd</span><span class=p>,</span><span class=n>fd</span><span class=p>,</span><span class=n>EPOLLOUT</span><span class=p>);</span>  <span class=c1>//删除监听    
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>modify_event</span><span class=p>(</span><span class=n>epollfd</span><span class=p>,</span><span class=n>fd</span><span class=p>,</span><span class=n>EPOLLIN</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>    
</span></span><span class=line><span class=cl>    <span class=n>memset</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=n>MAXSIZE</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//删除事件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=n>delete_event</span><span class=p>(</span><span class=kt>int</span> <span class=n>epollfd</span><span class=p>,</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span><span class=kt>int</span> <span class=n>state</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>epoll_event</span> <span class=n>ev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ev</span><span class=p>.</span><span class=n>events</span> <span class=o>=</span> <span class=n>state</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ev</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>fd</span> <span class=o>=</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>epoll_ctl</span><span class=p>(</span><span class=n>epollfd</span><span class=p>,</span><span class=n>EPOLL_CTL_DEL</span><span class=p>,</span><span class=n>fd</span><span class=p>,</span><span class=o>&amp;</span><span class=n>ev</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//修改事件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span> <span class=n>modify_event</span><span class=p>(</span><span class=kt>int</span> <span class=n>epollfd</span><span class=p>,</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span><span class=kt>int</span> <span class=n>state</span><span class=p>){</span>     
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>epoll_event</span> <span class=n>ev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ev</span><span class=p>.</span><span class=n>events</span> <span class=o>=</span> <span class=n>state</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ev</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>fd</span> <span class=o>=</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>epoll_ctl</span><span class=p>(</span><span class=n>epollfd</span><span class=p>,</span><span class=n>EPOLL_CTL_MOD</span><span class=p>,</span><span class=n>fd</span><span class=p>,</span><span class=o>&amp;</span><span class=n>ev</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//注：另外一端我就省了
</span></span></span></code></pre></div><h3 id=四epoll总结><a href=#四epoll总结 class=anchor-link>#</a>四、epoll总结</h3><p>在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描。而<strong>epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知</strong>。(<code>此处去掉了遍历文件描述符，而是通过监听回调的的机制</code>。这正是epoll的魅力所在。)</p><p><strong>epoll的优点主要是一下几个方面：</strong>
监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max查看，一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对于连接数量比较大的服务器来说根本不能满足。</p><p>IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</p><blockquote><p>如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。</p></blockquote></div></article><footer class=minimal-footer><div class=post-tag><a href=/tags/%E7%9F%A5%E8%AF%86/ rel=tag class=post-tag-link>#知识</a></div><div class=post-category><a href=/tech/ class="post-category-link active">tech</a> |</div></footer></div></main></div><script>"serviceWorker"in navigator&&window.addEventListener("load",function(){navigator.serviceWorker.register("/sw.js")})</script><script src=/js/medium-zoom.min.js></script>
<script>mediumZoom(document.querySelectorAll("div.post-body img"),{background:"hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)"})</script></body></html>