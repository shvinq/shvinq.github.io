<!doctype html><html lang=zh-cn><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=utf-8><meta name=generator content="Hugo 0.95.0"><meta name=theme-color content="#fff"><meta name=color-scheme content="light dark"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><title>源码分析-Tinyhttp项目 | SHVINQ</title><link rel=stylesheet href=/css/meme.min.css><script src=/js/meme.min.js></script>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&family=Cinzel+Decorative:wght@700&display=swap" media=print onload='this.media="all"'><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&family=Cinzel+Decorative:wght@700&display=swap"></noscript><meta name=author content="shvinq"><meta name=description content="Tinyhttpd源码解析 Tinyhttpd是J. David Blackstone写的一个轻量型Http Ser……"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=mask-icon href=/icons/safari-pinned-tab.svg color=#fff><link rel=apple-touch-icon sizes=180x180 href=/icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="SHVINQ"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="SHVINQ"><meta name=msapplication-starturl content="../../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../../icons/mstile-150x150.png"><link rel=manifest href=/manifest.json><link rel=canonical href=https://shvinq.com/tech/tinyhttp/><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","datePublished":"2021-10-01T07:13:58+08:00","dateModified":"2022-03-27T21:52:56+08:00","url":"https://shvinq.com/tech/tinyhttp/","headline":"源码分析-Tinyhttp项目","description":"Tinyhttpd源码解析 Tinyhttpd是J. David Blackstone写的一个轻量型Http Ser……","inLanguage":"zh-CN","articleSection":"tech","wordCount":5727,"image":["https://tuchuang-1258133230.cos.ap-shanghai.myqcloud.com/EasTYuCfd8n1ki7.png","https://tuchuang-1258133230.cos.ap-shanghai.myqcloud.com/Q5dCI4EicpNeuoS.png","https://tuchuang-1258133230.cos.ap-shanghai.myqcloud.com/9G2ZODXWJiEAM4F.png"],"author":{"@type":"Person","description":"Go Deep","email":"zhoushuiqing321@gmail.com","image":"https://shvinq.com/icons/cool1.png","url":"https://shvinq.com/","name":"shvinq"},"license":"在保留本文作者及本文链接的前提下，非商业用途随意转载分享。","publisher":{"@type":"Organization","name":"SHVINQ","logo":{"@type":"ImageObject","url":"https://shvinq.com/icons/cool1.png"},"url":"https://shvinq.com/"},"mainEntityOfPage":{"@type":"WebSite","@id":"https://shvinq.com/"}}</script><meta name=twitter:card content="summary_large_image"><meta property="og:title" content="源码分析-Tinyhttp项目"><meta property="og:description" content="Tinyhttpd源码解析 Tinyhttpd是J. David Blackstone写的一个轻量型Http Ser……"><meta property="og:url" content="https://shvinq.com/tech/tinyhttp/"><meta property="og:site_name" content="SHVINQ"><meta property="og:locale" content="zh"><meta property="og:image" content="https://tuchuang-1258133230.cos.ap-shanghai.myqcloud.com/EasTYuCfd8n1ki7.png"><meta property="og:type" content="article"><meta property="article:published_time" content="2021-10-01T07:13:58+08:00"><meta property="article:modified_time" content="2022-03-27T21:52:56+08:00"><meta property="article:section" content="tech"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap" media=print onload='this.media="all"'><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@700&text=reuixiy&display=swap"></noscript></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=/ class=brand>SHVINQ</a></div><nav class=nav><ul class=menu id=menu><li class=menu-item><a href><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon life"><path d="M301.1 212c4.4 4.4 4.4 11.9.0 16.3l-9.7 9.7c-4.4 4.7-11.9 4.7-16.6.0l-10.5-10.5c-4.4-4.7-4.4-11.9.0-16.6l9.7-9.7c4.4-4.4 11.9-4.4 16.6.0l10.5 10.8zm-30.2-19.7c3-3 3-7.8.0-10.5-2.8-3-7.5-3-10.5.0-2.8 2.8-2.8 7.5.0 10.5 3.1 2.8 7.8 2.8 10.5.0zm-26 5.3c-3 2.8-3 7.5.0 10.2 2.8 3 7.5 3 10.5.0 2.8-2.8 2.8-7.5.0-10.2-3-3-7.7-3-10.5.0zm72.5-13.3c-19.9-14.4-33.8-43.2-11.9-68.1 21.6-24.9 40.7-17.2 59.8.8 11.9 11.3 29.3 24.9 17.2 48.2-12.5 23.5-45.1 33.2-65.1 19.1zm47.7-44.5c-8.9-10-23.3 6.9-15.5 16.1 7.4 9 32.1 2.4 15.5-16.1zM504 256c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-66.2 42.6c2.5-16.1-20.2-16.6-25.2-25.7-13.6-24.1-27.7-36.8-54.5-30.4 11.6-8 23.5-6.1 23.5-6.1.3-6.4.0-13-9.4-24.9 3.9-12.5.3-22.4.3-22.4 15.5-8.6 26.8-24.4 29.1-43.2 3.6-31-18.8-59.2-49.8-62.8-22.1-2.5-43.7 7.7-54.3 25.7-23.2 40.1 1.4 70.9 22.4 81.4-14.4-1.4-34.3-11.9-40.1-34.3-6.6-25.7 2.8-49.8 8.9-61.4.0.0-4.4-5.8-8-8.9.0.0-13.8.0-24.6 5.3 11.9-15.2 25.2-14.4 25.2-14.4.0-6.4-.6-14.9-3.6-21.6-5.4-11-23.8-12.9-31.7 2.8.1-.2.3-.4.4-.5-5 11.9-1.1 55.9 16.9 87.2-2.5 1.4-9.1 6.1-13 10-21.6 9.7-56.2 60.3-56.2 60.3-28.2 10.8-77.2 50.9-70.6 79.7.3 3 1.4 5.5 3 7.5-2.8 2.2-5.5 5-8.3 8.3-11.9 13.8-5.3 35.2 17.7 24.4 15.8-7.2 29.6-20.2 36.3-30.4.0.0-5.5-5-16.3-4.4 27.7-6.6 34.3-9.4 46.2-9.1 8 3.9 8-34.3 8-34.3.0-14.7-2.2-31-11.1-41.5 12.5 12.2 29.1 32.7 28 60.6-.8 18.3-15.2 23-15.2 23-9.1 16.6-43.2 65.9-30.4 106 0 0-9.7-14.9-10.2-22.1-17.4 19.4-46.5 52.3-24.6 64.5 26.6 14.7 108.8-88.6 126.2-142.3 34.6-20.8 55.4-47.3 63.9-65 22 43.5 95.3 94.5 101.1 59z"/></svg><span class=menu-item-name>生活</span></a></li><li class="menu-item active"><a href=/tech/><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon tech"><path d="M512 256c0 141.2-114.7 256-256 256C114.8 512 0 397.3.0 256S114.7.0 256 0s256 114.7 256 256zm-32 0c0-123.2-100.3-224-224-224C132.5 32 32 132.5 32 256s100.5 224 224 224 224-100.5 224-224zM160.9 124.6l86.9 37.1-37.1 86.9-86.9-37.1 37.1-86.9zm110 169.1 46.6 94h-14.6l-50-1e2-48.9 1e2h-14l51.1-106.9-22.3-9.4 6-14 68.6 29.1-6 14.3-16.5-7.1zm-11.8-116.3 68.6 29.4-29.4 68.3L230 246l29.1-68.6zm80.3 42.9 54.6 23.1-23.4 54.3-54.3-23.1 23.1-54.3z"/></svg><span class=menu-item-name>技术</span></a></li><li class=menu-item><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" class="icon about"><path d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 96c48.6.0 88 39.4 88 88s-39.4 88-88 88-88-39.4-88-88 39.4-88 88-88zm0 344c-58.7.0-111.3-26.6-146.5-68.2 18.8-35.4 55.6-59.8 98.5-59.8 2.4.0 4.8.4 7.1 1.1 13 4.2 26.6 6.9 40.9 6.9s28-2.7 40.9-6.9c2.3-.7 4.7-1.1 7.1-1.1 42.9.0 79.7 24.4 98.5 59.8C359.3 421.4 306.7 448 248 448z"/></svg><span class=menu-item-name>关于</span></a></li><li class=menu-item><a id=theme-switcher href=#><span class="icon theme-icon-light">🌝</span><span class="icon theme-icon-dark">🌚</span></a></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label>
<label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><div class=main-inner><article class="content post h-entry" data-align=justify data-type=tech data-toc-num=true><h1 class="post-title p-name">源码分析-Tinyhttp项目</h1><div class="post-body e-content"><h3 id=tinyhttpd源码解析><a href=#tinyhttpd源码解析 class=anchor-link>#</a>Tinyhttpd源码解析</h3><p>Tinyhttpd是J. David Blackstone写的一个轻量型Http Server程序，里面包含了socket编程、多线程编程等知识，值得学习一下。</p><p><a href=https://github.com/EZLippi/Tinyhttpd target=_blank rel=noopener>Tinyhttp源码Github下载</a></p><p><code>Tinyhttpd</code>运行流程图如下：</p><p><img src=https://tuchuang-1258133230.cos.ap-shanghai.myqcloud.com/EasTYuCfd8n1ki7.png alt=image.png></p><p><strong>整体工作过程：</strong></p><p>1.启动服务器，可以指定或随机选取端口进行启动，调用startu函数创建服务端socket。</p><p>2.当收到一个http的连接请求时，分配一个线程调用accept_request函数去处理该请求。</p><p>3.解析http请求消息来获取请求方法method和请求的url。如果是GET方法则额外保存url中?后面的参数信息</p><p>4.将格式化的url存入path字符串中来表示此次请求服务器的文件路径，该tinyhttpd程序的"/"目录是在htdpcs下。如果客户端请求消息是以"/"结尾或者请求的是目录，则在path后加上index.html，表示访问主页。</p><p>5.如果文件路径合法，对于无参数的GET请求则直接调用serve_file函数将文件内容写入客户端socket；其他情况（带参数 GET，POST 方式，url 为可执行文件），则调用 excute_cgi 函数执行 cgi 脚本。</p><p>6.如果是POST方法，则需要额外获取Content-Length信息</p><p>7.fork出子进程和创建两个管道cgi_input和cgi_output给父子进程交互信息</p><p>8.子进程执行cgi脚本，并将子进程的标准输入修改重定向cgi_input的读取端，标准输出重定向到cgi_output的写入端；另外对于GET方法则设置request_method的环境变量，对于POST则设置content-length环境变量。请调用execl函数执行cgi脚本程序来替换该子进程。</p><p>9.父进程关闭管道cgi_input的读取端和cgi_output的写入端。当请求方式是POST时将从客户端获取的信息通过管道cgi_input[1]向子进程写入，此时是写入到了子进程的标准输入；然后通过cgi_output[0]管道从子进程读取数据发送给客户端，此时是从子进程的标准输出读取的。最后关闭管道，等待子进程结束。</p><p>源码阅读顺序： main -> startup -> accept_request -> execute_cgi。</p><h4 id=1http的getpost请求消息格式><a href=#1http的getpost请求消息格式 class=anchor-link>#</a>1.Http的GET/POST请求消息格式</h4><p><img src=https://tuchuang-1258133230.cos.ap-shanghai.myqcloud.com/Q5dCI4EicpNeuoS.png alt=image.png></p><p>标准GET请求</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>GET</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>192.168.0.1:47310</span>
</span></span><span class=line><span class=cl><span class=n>Connection</span><span class=o>:</span> <span class=l>keep-alive</span>
</span></span><span class=line><span class=cl><span class=err>...</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=err>GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n
</span></span></span></code></pre></div><p>标准POST请求​</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=err>POST / myhttpd.cgi HTTP / 1.1
</span></span></span><span class=line><span class=cl><span class=err>Host: 192.168.0.1 : 47310
</span></span></span><span class=line><span class=cl><span class=err>Connection : keep - alive
</span></span></span><span class=line><span class=cl><span class=err>Content - Length : 10
</span></span></span><span class=line><span class=cl><span class=err>...
</span></span></span><span class=line><span class=cl><span class=err>Form Data
</span></span></span></code></pre></div><h4 id=2main函数><a href=#2main函数 class=anchor-link>#</a>2.Main函数</h4><p>以下是<code>main</code>函数代码实现</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>server_sock</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>       <span class=c1>//创建服务端套接字
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>u_short</span> <span class=n>port</span> <span class=o>=</span> <span class=mi>4000</span><span class=p>;</span>        <span class=c1>//定义端口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>client_sock</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=n>client_name</span><span class=p>;</span>     <span class=c1>//客户端地址变量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>socklen_t</span>  <span class=n>client_name_len</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>client_name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_t</span> <span class=n>newthread</span><span class=p>;</span>        <span class=c1>//线程变量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>server_sock</span> <span class=o>=</span> <span class=n>startup</span><span class=p>(</span><span class=o>&amp;</span><span class=n>port</span><span class=p>);</span>       <span class=c1>//调用自定义函数startup，初始化服务器段套接字
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;httpd running on port %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 一直循环处理新连接的到来，并创建并分配线程去处理该连接 */</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>client_sock</span> <span class=o>=</span> <span class=n>accept</span><span class=p>(</span><span class=n>server_sock</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>client_name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=o>&amp;</span><span class=n>client_name_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>client_sock</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=n>error_die</span><span class=p>(</span><span class=s>&#34;accept&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/*创建线程，执行线程主函数accept_request(),并将连接套接字传入该函数*/</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>newthread</span> <span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>accept_request</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)(</span><span class=n>intptr_t</span><span class=p>)</span><span class=n>client_sock</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;pthread_create&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>close</span><span class=p>(</span><span class=n>server_sock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>函数流程如下：</p><ol><li>调用startup函数初始化一个服务器socket</li><li>进入循环，通过accep函数来受理客户端连接请求</li><li>如果接收到新请求在调用pthread_create建立新线程</li><li>线程中调用accept_request函数，处理请求</li></ol><p>下文会分析startup函数，这里分析下accept函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>accept</span><span class=p>(</span><span class=n>server_sock</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>client_name</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>client_name_len</span><span class=p>);</span>
</span></span></code></pre></div><p>该函数接受一个套接字、ipv4地址结构变量指针以及对应长度，函数返回是新的连接套接字，CS端通过其通信。</p><p><code>accept</code>函数有两个重要特点：</p><ol><li>如果没有 <code>connect</code> 请求，函数调用会被阻塞，直到接收到 <code>connect</code> 请求</li><li>在与客户端的套接字建立连接时，<code>accept</code> 函数创建一个新的套接字，并用新的套接字与客户端连接，原始的套接字依然处于打开状态，可以用于继续监听端口。</li></ol><h4 id=3套接字初始化函数startup><a href=#3套接字初始化函数startup class=anchor-link>#</a>3.套接字初始化函数startup</h4><p>原始代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>startup</span><span class=p>(</span><span class=n>u_short</span> <span class=o>*</span><span class=n>port</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>httpd</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>on</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>httpd</span> <span class=o>=</span> <span class=n>socket</span><span class=p>(</span><span class=n>PF_INET</span><span class=p>,</span> <span class=n>SOCK_STREAM</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>httpd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=n>error_die</span><span class=p>(</span><span class=s>&#34;socket&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>name</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>name</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span><span class=p>.</span><span class=n>sin_family</span> <span class=o>=</span> <span class=n>AF_INET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span><span class=p>.</span><span class=n>sin_port</span> <span class=o>=</span> <span class=n>htons</span><span class=p>(</span><span class=o>*</span><span class=n>port</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span><span class=p>.</span><span class=n>sin_addr</span><span class=p>.</span><span class=n>s_addr</span> <span class=o>=</span> <span class=n>htonl</span><span class=p>(</span><span class=n>INADDR_ANY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*此处调用setsockopt方法，SO_REUSEADDR参数表示允许重用本地地址和端口*/</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>setsockopt</span><span class=p>(</span><span class=n>httpd</span><span class=p>,</span> <span class=n>SOL_SOCKET</span><span class=p>,</span> <span class=n>SO_REUSEADDR</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>on</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>on</span><span class=p>)))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=n>error_die</span><span class=p>(</span><span class=s>&#34;setsockopt failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>bind</span><span class=p>(</span><span class=n>httpd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>name</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>name</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=n>error_die</span><span class=p>(</span><span class=s>&#34;bind&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>port</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>  <span class=cm>/* if dynamically allocating a port */</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>socklen_t</span> <span class=n>namelen</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=cm>/*调用 getsockname()获取系统给 httpd 随机分配的端口号*/</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>getsockname</span><span class=p>(</span><span class=n>httpd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>name</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>namelen</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>error_die</span><span class=p>(</span><span class=s>&#34;getsockname&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>port</span> <span class=o>=</span> <span class=n>ntohs</span><span class=p>(</span><span class=n>name</span><span class=p>.</span><span class=n>sin_port</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>listen</span><span class=p>(</span><span class=n>httpd</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=n>error_die</span><span class=p>(</span><span class=s>&#34;listen&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>(</span><span class=n>httpd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>初始化流程比较简单，大多是固定的代码：</p><ol><li>调用 <code>socket</code> 函数，创建一个一套接字</li><li>创建 <code>sockaddr_in</code> 结构体，并设置对应的 ip 和 端口</li><li>通过 <code>bind</code> 函数，绑定套接字的 ip 和 端口</li><li>调用 <code>listen</code> 函数，监听请求</li></ol><p>其中具体分析写<code>sockaddr_in</code>结构体，主要包含了地址和端口信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>in_addr</span> <span class=p>{</span>                <span class=cm>/* IPv4 4-byte address */</span>
</span></span><span class=line><span class=cl>    <span class=n>in_addr_t</span> <span class=n>s_addr</span><span class=p>;</span>           <span class=cm>/* Unsigned 32-bit integer */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=p>{</span>            <span class=cm>/* IPv4 socket address */</span>
</span></span><span class=line><span class=cl>    <span class=n>sa_family_t</span>    <span class=n>sin_family</span><span class=p>;</span>  <span class=cm>/* Address family (AF_INET) */</span>
</span></span><span class=line><span class=cl>    <span class=n>in_port_t</span>      <span class=n>sin_port</span><span class=p>;</span>    <span class=cm>/* Port number */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>in_addr</span> <span class=n>sin_addr</span><span class=p>;</span>    <span class=cm>/* IPv4 address */</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span>  <span class=n>__pad</span><span class=p>[</span><span class=n>X</span><span class=p>];</span>    <span class=cm>/* Pad to size of &#39;sockaddr&#39;
</span></span></span><span class=line><span class=cl><span class=cm>};                                 structure (16 bytes) */</span>
</span></span></code></pre></div><p>接下来startup函数调用<code>setsocket</code>函数，设置套接字的一些属性，其中SO_REUSEADDR是一个很有用的选项参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>setsockopt</span><span class=p>(</span><span class=n>httpd</span><span class=p>,</span> <span class=n>SOL_SOCKET</span><span class=p>,</span> <span class=n>SO_REUSEADDR</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>on</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>on</span><span class=p>))</span>
</span></span></code></pre></div><p>一般服务器的监听socket都应该打开它。其允许服务器bind一个地址，即使这个地址当前已经存在已建立的连接，比如：</p><ul><li>服务器启动后，有客户端连接并已建立，如果服务器主动关闭，那么和客户端的连接会处于TIME_WAIT状态，此时再次启动服务器，就会bind不成功，报：Address already in use。</li><li>服务器父进程监听客户端，当和客户端建立链接后，fork一个子进程专门处理客户端的请求，如果父进程停止，因为子进程还和客户端有连接，所以再次启动父进程，也会报Address already in use。</li></ul><p>在 TCP 连接中，当端口收到或者发送 FIN/ACK 请求后，端口并不会立即释放，而是处于 <code>TIME_WAIT</code> 状态（该状态一般持续 2 分钟），此时端口是无法与套接字绑定的。设置 <code>SO_REUSEADDR</code> 可以让套接字绑定处于 <code>TIME_WAIT</code> 状态的端口。具体分析可参考《TCP/IP详解》</p><p>最后调用<code>listen</code>函数，让套接字进入被动监听状态。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>listen</span><span class=p>(</span><span class=n>httpd</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>		
</span></span></code></pre></div><p>其中第二个参数5代表请求队列的长度。</p><blockquote><p>当套接字正在处理客户端请求时，如果有新的请求进来，套接字是没法处理的，只能把它放进缓冲区，待当前请求处理完毕后，再从缓冲区中读取出来处理。如果不断有新的请求进来，它们就按照先后顺序在缓冲区中排队，直到缓冲区满。这个缓冲区，就称为请求队列（Request Queue）。</p></blockquote><h4 id=4请求消息解析函数accept_request><a href=#4请求消息解析函数accept_request class=anchor-link>#</a>4.请求消息解析函数accept_request</h4><p>函数源代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>accept_request</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>client</span> <span class=o>=</span> <span class=p>(</span><span class=n>intptr_t</span><span class=p>)</span><span class=n>arg</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>1024</span><span class=p>];</span>         <span class=c1>//接收客户端消息的缓冲区
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>size_t</span> <span class=n>numchars</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>method</span><span class=p>[</span><span class=mi>255</span><span class=p>];</span>       <span class=c1>//获取客户端的请求方式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span> <span class=n>url</span><span class=p>[</span><span class=mi>255</span><span class=p>];</span>          <span class=c1>//获取客户端请求的URL
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span> <span class=n>path</span><span class=p>[</span><span class=mi>512</span><span class=p>];</span>         <span class=c1>//获取客户端请求的路径
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>size_t</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>stat</span> <span class=n>st</span><span class=p>;</span>         <span class=c1>//用来存储文件状态的结构体
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>cgi</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>      		<span class=c1>//CGI程序调用标记
</span></span></span><span class=line><span class=cl><span class=c1></span>                      
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>query_string</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*http消息中一行，numchars表示这行信息的结尾在buf中的位置*/</span>
</span></span><span class=line><span class=cl>    <span class=n>numchars</span> <span class=o>=</span> <span class=n>get_line</span><span class=p>(</span><span class=n>client</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>));</span>      
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>ISspace</span><span class=p>(</span><span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>method</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>method</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>         <span class=c1>//用method来表示请求方式
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>j</span><span class=o>=</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>method</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*此处判断方法是否支持解析或者方法是否正常，不支持则调用unimplemented函数返回错误方法的响应消息给客户端并退出解析结束线程*/</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>strcasecmp</span><span class=p>(</span><span class=n>method</span><span class=p>,</span> <span class=s>&#34;GET&#34;</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>strcasecmp</span><span class=p>(</span><span class=n>method</span><span class=p>,</span> <span class=s>&#34;POST&#34;</span><span class=p>))</span>        
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>unimplemented</span><span class=p>(</span><span class=n>client</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*如果是post方法，则将调用cgi函数的标记置为true*/</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>strcasecmp</span><span class=p>(</span><span class=n>method</span><span class=p>,</span> <span class=s>&#34;POST&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=n>cgi</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>ISspace</span><span class=p>(</span><span class=n>buf</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>j</span> <span class=o>&lt;</span> <span class=n>numchars</span><span class=p>))</span> <span class=n>j</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/*继续往后移动j来获取url信息作为字符串*/</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>ISspace</span><span class=p>(</span><span class=n>buf</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>url</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>j</span> <span class=o>&lt;</span> <span class=n>numchars</span><span class=p>))</span>     
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>url</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>buf</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span><span class=o>++</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>url</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/*比较method字符串和&#34;GET&#34;是否相同，相同返回0，大于返回正值，反正返回负值。此处是处理GET方法*/</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>strcasecmp</span><span class=p>(</span><span class=n>method</span><span class=p>,</span> <span class=s>&#34;GET&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/*用query_string来获取?后面的GET请求的参数*/</span>
</span></span><span class=line><span class=cl>        <span class=n>query_string</span> <span class=o>=</span> <span class=n>url</span><span class=p>;</span>                     
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>((</span><span class=o>*</span><span class=n>query_string</span> <span class=o>!=</span> <span class=sc>&#39;?&#39;</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=o>*</span><span class=n>query_string</span> <span class=o>!=</span> <span class=sc>&#39;\0&#39;</span><span class=p>))</span> <span class=n>query_string</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/*如果有参数则将cgi标记置为true，此时query_string指向了?后面的GET参数*/</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>query_string</span> <span class=o>==</span> <span class=sc>&#39;?&#39;</span><span class=p>)</span>       
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>cgi</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=o>*</span><span class=n>query_string</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>query_string</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/*将字符串&#34;htdoc&#34;与字符串url进行拼接，并保存在path变量中*/</span>
</span></span><span class=line><span class=cl>    <span class=n>sprintf</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=s>&#34;htdocs%s&#34;</span><span class=p>,</span> <span class=n>url</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=cm>/*如果此时path是以&#34;/&#34;结尾，则将字符串&#34;index.html&#34;追加到path后面*/</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>path</span><span class=p>[</span><span class=n>strlen</span><span class=p>(</span><span class=n>path</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;/&#39;</span><span class=p>)</span> <span class=n>strcat</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=s>&#34;index.html&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 调用stat函数，通过path中的文件路径获取文件或文件路径信息，并保存到struct stat st中 */</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>stat</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>st</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/*stat()函数执行失败返回-1，处理并丢弃剩下的请求头并返回错误信息*/</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>((</span><span class=n>numchars</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>strcmp</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>))</span>  <span class=cm>/* read &amp; discard headers */</span>
</span></span><span class=line><span class=cl>            <span class=n>numchars</span> <span class=o>=</span> <span class=n>get_line</span><span class=p>(</span><span class=n>client</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>not_found</span><span class=p>(</span><span class=n>client</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/*如果文件路径合法，对于无参数的 GET 请求，直接将文件内容写入客户端套接字。其他情况（带参数GET，POST 方式，url 为可执行文件），则调用 excute_cgi 函数执行 cgi 脚本*/</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>((</span><span class=n>st</span><span class=p>.</span><span class=n>st_mode</span> <span class=o>&amp;</span> <span class=n>S_IFMT</span><span class=p>)</span> <span class=o>==</span> <span class=n>S_IFDIR</span><span class=p>)</span> <span class=n>strcat</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=s>&#34;/index.html&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>((</span><span class=n>st</span><span class=p>.</span><span class=n>st_mode</span> <span class=o>&amp;</span> <span class=n>S_IXUSR</span><span class=p>)</span><span class=o>||</span><span class=p>(</span><span class=n>st</span><span class=p>.</span><span class=n>st_mode</span> <span class=o>&amp;</span> <span class=n>S_IXGRP</span><span class=p>)</span><span class=o>||</span><span class=p>(</span><span class=n>st</span><span class=p>.</span><span class=n>st_mode</span> <span class=o>&amp;</span> <span class=n>S_IXOTH</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>cgi</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>   <span class=cm>/*简单的GET请求且？后无参数时，不执行cgi函数，而是调用serve_file函数将客户端请求的文件发送给客户端*/</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>cgi</span><span class=p>)</span> <span class=n>serve_file</span><span class=p>(</span><span class=n>client</span><span class=p>,</span> <span class=n>path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>   <span class=cm>/*执行cgi函数，将连接套接字，文件路径，请求方式和?后的GET参数传入。*/</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=n>execute_cgi</span><span class=p>(</span><span class=n>client</span><span class=p>,</span> <span class=n>path</span><span class=p>,</span> <span class=n>method</span><span class=p>,</span> <span class=n>query_string</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>close</span><span class=p>(</span><span class=n>client</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>accept_request</code> 函数主要涉及的是对于 request header 的处理，整体流程如下：</p><ol><li>提取 request 的类型（GET 或 POST）</li><li>提取 url 信息</li><li>如果是 GET 请求，则提取 url 中的参数信息（?之后参数）</li><li>如果 url 结尾是 / 或者该地址对应一个目录，默认调用该目录下的 index.html</li><li>如果不是 CGI，则调用 <code>serve_file</code>，将文本内容返回给客户端</li><li>如果是 CGI，调用 <code>execute_cgi</code>，执行 CGI 脚本程序</li><li>断开连接</li></ol><p>在对 request header 的处理中，大量调用了 <code>get_line</code> 函数。该函数用于读取文件的下一行信息，适用于不同的换行符（<code>\n</code> 或 <code>\r\n</code>）。</p><p>该函数使用的<code>stat</code>函数，用于获取文件或文件路径状态信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>stat</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=k>struct</span> <span class=n>stat</span> <span class=o>*</span><span class=n>statbuf</span><span class=p>);</span>
</span></span></code></pre></div><p>其中<code>stat</code>结构体内容信息较多，具体源码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>stat</span>  
</span></span><span class=line><span class=cl><span class=p>{</span>   
</span></span><span class=line><span class=cl>    <span class=n>dev_t</span>       <span class=n>st_dev</span><span class=p>;</span>     <span class=cm>/* ID of device containing file -文件所在设备的ID*/</span>  
</span></span><span class=line><span class=cl>    <span class=n>ino_t</span>       <span class=n>st_ino</span><span class=p>;</span>     <span class=cm>/* inode number -inode节点号*/</span>    
</span></span><span class=line><span class=cl>    <span class=n>mode_t</span>      <span class=n>st_mode</span><span class=p>;</span>    <span class=cm>/* protection -保护模式?*/</span>    
</span></span><span class=line><span class=cl>    <span class=n>nlink_t</span>     <span class=n>st_nlink</span><span class=p>;</span>   <span class=cm>/* number of hard links -链向此文件的连接数(硬连接)*/</span>    
</span></span><span class=line><span class=cl>    <span class=n>uid_t</span>       <span class=n>st_uid</span><span class=p>;</span>     <span class=cm>/* user ID of owner -user id*/</span>    
</span></span><span class=line><span class=cl>    <span class=n>gid_t</span>       <span class=n>st_gid</span><span class=p>;</span>     <span class=cm>/* group ID of owner - group id*/</span>    
</span></span><span class=line><span class=cl>    <span class=n>dev_t</span>       <span class=n>st_rdev</span><span class=p>;</span>    <span class=cm>/* device ID (if special file) -设备号，针对设备文件*/</span>    
</span></span><span class=line><span class=cl>    <span class=n>off_t</span>       <span class=n>st_size</span><span class=p>;</span>    <span class=cm>/* total size, in bytes -文件大小，字节为单位*/</span>    
</span></span><span class=line><span class=cl>    <span class=n>blksize_t</span>   <span class=n>st_blksize</span><span class=p>;</span> <span class=cm>/* blocksize for filesystem I/O -系统块的大小*/</span>    
</span></span><span class=line><span class=cl>    <span class=n>blkcnt_t</span>    <span class=n>st_blocks</span><span class=p>;</span>  <span class=cm>/* number of blocks allocated -文件所占块数*/</span>    
</span></span><span class=line><span class=cl>    <span class=n>time_t</span>      <span class=n>st_atime</span><span class=p>;</span>   <span class=cm>/* time of last access -最近存取时间*/</span>    
</span></span><span class=line><span class=cl>    <span class=n>time_t</span>      <span class=n>st_mtime</span><span class=p>;</span>   <span class=cm>/* time of last modification -最近修改时间*/</span>    
</span></span><span class=line><span class=cl>    <span class=n>time_t</span>      <span class=n>st_ctime</span><span class=p>;</span>   <span class=cm>/* time of last status change - */</span>    
</span></span><span class=line><span class=cl><span class=p>};</span> 
</span></span></code></pre></div><h4 id=5cgi执行函数execute_cgi><a href=#5cgi执行函数execute_cgi class=anchor-link>#</a>5.CGI执行函数execute_cgi</h4><p>函数源代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*参数为连接套接字，文件路径，请求方式和?后的GET参数*/</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>execute_cgi</span><span class=p>(</span><span class=kt>int</span> <span class=n>client</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>method</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>query_string</span><span class=p>)</span>       
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>1024</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>cgi_output</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>cgi_input</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>numchars</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>content_length</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>buf</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;A&#39;</span><span class=p>;</span> <span class=n>buf</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=cm>/*如果是GET请求，无须处理下面的信息，所以继续执行处理并丢弃剩下的请求头信息*/</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>strcasecmp</span><span class=p>(</span><span class=n>method</span><span class=p>,</span> <span class=s>&#34;GET&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>     
</span></span><span class=line><span class=cl>    <span class=p>{</span>    <span class=k>while</span> <span class=p>((</span><span class=n>numchars</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>strcmp</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>))</span>  <span class=cm>/* read &amp; discard headers */</span>
</span></span><span class=line><span class=cl>            <span class=n>numchars</span> <span class=o>=</span> <span class=n>get_line</span><span class=p>(</span><span class=n>client</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>strcasecmp</span><span class=p>(</span><span class=n>method</span><span class=p>,</span> <span class=s>&#34;POST&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=cm>/*POST方法*/</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>numchars</span> <span class=o>=</span> <span class=n>get_line</span><span class=p>(</span><span class=n>client</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>));</span>      <span class=c1>//获取下一行信息
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>while</span> <span class=p>((</span><span class=n>numchars</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>strcmp</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/*如果是POST请求，就需要得到 Content-Length,content-Length 字符串长度为15从 17 位开				  始是具体的长度信息*/</span>
</span></span><span class=line><span class=cl>            <span class=n>buf</span><span class=p>[</span><span class=mi>15</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>strcasecmp</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=s>&#34;Content-Length:&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>content_length</span> <span class=o>=</span> <span class=n>atoi</span><span class=p>(</span><span class=o>&amp;</span><span class=p>(</span><span class=n>buf</span><span class=p>[</span><span class=mi>16</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>numchars</span> <span class=o>=</span> <span class=n>get_line</span><span class=p>(</span><span class=n>client</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>content_length</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>bad_request</span><span class=p>(</span><span class=n>client</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=cm>/*HEAD or other*/</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/*pipe系统调用建立管道*/</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pipe</span><span class=p>(</span><span class=n>cgi_output</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cannot_execute</span><span class=p>(</span><span class=n>client</span><span class=p>);</span>         <span class=c1>//调用cannot_execute函数通知客户端无法执行CGI脚本
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pipe</span><span class=p>(</span><span class=n>cgi_input</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cannot_execute</span><span class=p>(</span><span class=n>client</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span> <span class=p>(</span><span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=p>)</span> <span class=p>{</span>         <span class=c1>//创建子进程执行CGI脚本
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>cannot_execute</span><span class=p>(</span><span class=n>client</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>sprintf</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=s>&#34;HTTP/1.0 200 OK</span><span class=se>\r\n</span><span class=s>&#34;</span><span class=p>);</span>        <span class=c1>//发送200OK状态码给客户端
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>send</span><span class=p>(</span><span class=n>client</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>strlen</span><span class=p>(</span><span class=n>buf</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>  <span class=cm>/* child: CGI script */</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>meth_env</span><span class=p>[</span><span class=mi>255</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>query_env</span><span class=p>[</span><span class=mi>255</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>length_env</span><span class=p>[</span><span class=mi>255</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/*复制cgi_output[1]文件描述符到标准输出，此时标准输出被关闭*/</span>
</span></span><span class=line><span class=cl>        <span class=n>dup2</span><span class=p>(</span><span class=n>cgi_output</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>STDOUT</span><span class=p>);</span>   
</span></span><span class=line><span class=cl>        <span class=cm>/*复制cgi_input[0]文件描述符到标准输入，此时标准输入被关闭*/</span>
</span></span><span class=line><span class=cl>        <span class=n>dup2</span><span class=p>(</span><span class=n>cgi_input</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>STDIN</span><span class=p>);</span>       
</span></span><span class=line><span class=cl>        <span class=n>close</span><span class=p>(</span><span class=n>cgi_output</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>close</span><span class=p>(</span><span class=n>cgi_input</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/*将拼接字符串，保存到meth_env中*/</span>
</span></span><span class=line><span class=cl>        <span class=n>sprintf</span><span class=p>(</span><span class=n>meth_env</span><span class=p>,</span> <span class=s>&#34;REQUEST_METHOD=%s&#34;</span><span class=p>,</span> <span class=n>method</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/*调用putenv函数将meth_env添加到环境变量中*/</span>
</span></span><span class=line><span class=cl>        <span class=n>putenv</span><span class=p>(</span><span class=n>meth_env</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/*如果是GET请求，将？后面的参数也加入环境变量*/</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>strcasecmp</span><span class=p>(</span><span class=n>method</span><span class=p>,</span> <span class=s>&#34;GET&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>sprintf</span><span class=p>(</span><span class=n>query_env</span><span class=p>,</span> <span class=s>&#34;QUERY_STRING=%s&#34;</span><span class=p>,</span> <span class=n>query_string</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>putenv</span><span class=p>(</span><span class=n>query_env</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=cm>/*如果是POST方法，将content-length加入环境变量*/</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=p>{</span>   <span class=cm>/* POST */</span>
</span></span><span class=line><span class=cl>            <span class=n>sprintf</span><span class=p>(</span><span class=n>length_env</span><span class=p>,</span> <span class=s>&#34;CONTENT_LENGTH=%d&#34;</span><span class=p>,</span> <span class=n>content_length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>putenv</span><span class=p>(</span><span class=n>length_env</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=cm>/*exec函数族启动一个新程序，替换原有的进程。因此这个新的被exec执行的进程的PID不会改变，和调用exec函数的进程一样*/</span>
</span></span><span class=line><span class=cl>        <span class=n>execl</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>                                  
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*子进程的标准输入输出和cgi_input和cgi_output绑定了，父进程可以通过 cgi_input 和 cgi_output 获取子进程中cgi脚本的标准输入和标准输出*/</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>close</span><span class=p>(</span><span class=n>cgi_output</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>close</span><span class=p>(</span><span class=n>cgi_input</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>strcasecmp</span><span class=p>(</span><span class=n>method</span><span class=p>,</span> <span class=s>&#34;POST&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=cm>/*根据Content-Length读取客户端信息，并通过cgi_inputp[1]管道传入子进程的标准输入*/</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>content_length</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>recv</span><span class=p>(</span><span class=n>client</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>c</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>write</span><span class=p>(</span><span class=n>cgi_input</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>c</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=cm>/*通过cgi_output管道获取子进程标准输出，并写入到客户端*/</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>read</span><span class=p>(</span><span class=n>cgi_output</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>c</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=n>send</span><span class=p>(</span><span class=n>client</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>c</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>close</span><span class=p>(</span><span class=n>cgi_output</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>close</span><span class=p>(</span><span class=n>cgi_input</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>waitpid</span><span class=p>(</span><span class=n>pid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>status</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>函数的整体流程如下：</p><ol><li>对 POST 请求，根据 Content-Length 提取 body 中的信息</li><li>创建两个管道 cgi_input 和 cgi_output 用于进程间通信</li><li>调用 <code>fork</code> 建立子进程</li><li>子进程调用 <code>dup2</code> 将标准输入与标准输出分别重定向到对应管道的读端和写端</li><li>在子进程中设置环境变量，并调用 <code>execl</code>，执行 CGI 脚本</li><li>父进程通过管道向 CGI 脚本传入参数，并获取脚本的返回结果，再将结果传给客户端</li><li>父进程等待子结束</li></ol><p>这里的重点是父子进程利用管道实现IPC。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pipe</span><span class=p>(</span><span class=kt>int</span> <span class=n>filedes</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span></code></pre></div><p>调用 <code>pipe</code> 函数，得到两个文件描述符，分别对应管道的读端 <code>filedes[0]</code> 和写端 <code>filedes[1]</code>，当程序在写端写入数据时，在读端可以读取到写入的数据。接着，通过 <code>fork</code> 函数，得到一个子进程。由于子进程与父进程拥有完全相同的变量，因此子进程也有对应管道读端和写端的两个文件描述符。之后，只需要关闭一侧的读端和另一侧的写端，就可以实现进程间的通信。</p><p><img src=https://tuchuang-1258133230.cos.ap-shanghai.myqcloud.com/9G2ZODXWJiEAM4F.png alt=image.png></p><p>接下来调用<code>dup2</code>系统调用，对子进程的标准输入输出进行重定向。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>dup2</span><span class=p>(</span><span class=kt>int</span> <span class=n>oldfd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>newfd</span><span class=p>);</span>  <span class=c1>//dup2可以用参数newfd指定新文件描述符的数值。
</span></span></span></code></pre></div><p>若参数newfd已经被程序使用，则系统就会将newfd所指的文件关闭，若newfd等于oldfd，则返回newfd,而不关闭newfd所指的文件。dup2所复制的文件描述符与原来的文件描述符共享各种文件状态、共享所有的锁定、读写位置和各项权限或flags等</p><p>在这里实现了以下功能：</p><ul><li>子进程的标准输出将会写入到 <code>cgi_output</code> 的写端</li><li><code>cgi_input</code> 读端读取的数据将会作为子进程的标准输入</li></ul><p>在子进程完成标准输入和标准输出的重定向之后，调用 <code>execl</code> 函数，执行 CGI 脚本。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>execl</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span></code></pre></div><p>该函数会让进程加载新的程序，之前的程序包括缓存的数据都会被丢弃掉。此时，子进程就是 CGI 脚本的执行程序。</p><p>父进程只需要做两件事：</p><ul><li>调用 <code>recv</code> 函数，从客户端中接收数据，并将数据通过 <code>cgi_input[1]</code> 写入传入 CGI 脚本</li><li>从 <code>cgi_output[0]</code> 中读取 CGI 脚本的返回结果，并调用 <code>send</code> 函数，将结果发送给客户端</li></ul><p>该Tinyhttpd的源码主体已经解析完毕，当然还有获取一行信息的get_line()、从文件读入内容的cat()等函数，逻辑比较简单，读一遍大致就理解了，这里就不加以赘述。</p></div></article><footer class=minimal-footer><div class=post-tag><a href=/tags/%E6%BA%90%E7%A0%81/ rel=tag class=post-tag-link>#源码</a></div><div class=post-category><a href=/tech/ class="post-category-link active">tech</a> |</div></footer></div></main></div><script>"serviceWorker"in navigator&&window.addEventListener("load",function(){navigator.serviceWorker.register("/sw.js")})</script><script src=/js/medium-zoom.min.js></script>
<script>mediumZoom(document.querySelectorAll("div.post-body img"),{background:"hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)"})</script></body></html>